<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>インタラクティブ安定性解析 - SG/GFL/GFM モデル</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&family=Source+Code+Pro:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        :root {
            --bg-primary: #0f0f14;
            --bg-secondary: #1a1a24;
            --bg-card: #252538;
            --text-primary: #e8e8ec;
            --text-secondary: #a1a1aa;
            --accent-sg: #f59e0b;
            --accent-gfl: #3b82f6;
            --accent-gfm: #10b981;
            --border: #3f3f46;
            --success: #22c55e;
            --warning: #eab308;
            --danger: #ef4444;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            padding: 2rem;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 2rem;
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--accent-sg), var(--accent-gfl), var(--accent-gfm));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .control-panel {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border);
        }

        .model-tabs {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .tab {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            background: var(--bg-secondary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .tab.active {
            background: var(--accent-gfl);
            color: white;
        }

        .tab:hover {
            transform: translateY(-2px);
        }

        .parameter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .parameter-group {
            background: var(--bg-secondary);
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .parameter-group h3 {
            color: var(--accent-gfl);
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        input[type="range"], input[type="number"] {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Source Code Pro', monospace;
        }

        input[type="range"] {
            height: 6px;
            background: var(--border);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-gfl);
            cursor: pointer;
        }

        .range-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
        }

        .range-display input[type="range"] {
            flex: 1;
        }

        .range-display input[type="number"] {
            width: 80px;
            padding: 0.25rem;
        }

        .analysis-button {
            width: 100%;
            padding: 1rem;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, var(--accent-gfl), var(--accent-gfm));
            color: white;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .analysis-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }

        .results-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-top: 2rem;
        }

        .plot-container {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border);
            height: 500px;
        }

        .stability-indicator {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 2rem;
            border: 1px solid var(--border);
            text-align: center;
            margin-bottom: 2rem;
        }

        .stability-status {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }

        .stability-status.stable {
            color: var(--success);
        }

        .stability-status.unstable {
            color: var(--danger);
        }

        .stability-status.marginal {
            color: var(--warning);
        }

        .eigenvalue-list {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1rem;
            font-family: 'Source Code Pro', monospace;
            font-size: 0.9rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .model-info {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            border-left: 4px solid var(--accent-gfl);
        }

        .github-nav {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            gap: 1rem;
        }
        
        .nav-button {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: var(--accent-gfl);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
            transition: all 0.3s ease;
        }
        
        .nav-button:hover {
            background: #1d4ed8;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
        }
        
        .nav-button svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        @media (max-width: 768px) {
            .results-panel {
                grid-template-columns: 1fr;
            }
            
            .parameter-grid {
                grid-template-columns: 1fr;
            }
            
            body {
                padding: 1rem;
            }
            
            .github-nav {
                position: relative;
                top: auto;
                right: auto;
                justify-content: center;
                margin-bottom: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="github-nav">
        <a href="https://github.com/lutelute/modeling_INV_SG_rms_Model" class="nav-button" target="_blank">
            <svg viewBox="0 0 24 24">
                <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
            </svg>
            GitHub
        </a>
        <a href="../index.html" class="nav-button">
            <svg viewBox="0 0 24 24">
                <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
            </svg>
            ホーム
        </a>
        <a href="detailed_stability_analysis.html" class="nav-button">
            <svg viewBox="0 0 24 24">
                <path d="M14.5 2H6c-.55 0-1 .45-1 1v14c0 .55.45 1 1 1h12c.55 0 1-.45 1-1V6.5L14.5 2zM14 7V3.5L17.5 7H14z"/>
            </svg>
            詳細版
        </a>
    </div>
    <div class="container">
        <h1>インタラクティブ安定性解析ツール</h1>
        
        <div class="control-panel">
            <div class="model-tabs">
                <button class="tab active" onclick="selectModel('sg')">同期発電機 (SG)</button>
                <button class="tab" onclick="selectModel('gfl')">Grid-Following (GFL)</button>
                <button class="tab" onclick="selectModel('gfm')">Grid-Forming (GFM)</button>
            </div>

            <div class="model-info" id="modelInfo">
                <strong>同期発電機モデル</strong><br>
                古典的な同期発電機の小信号モデル。回転子角度δと角速度ωを状態変数とする2次システム。
            </div>

            <div class="parameter-grid" id="parameterGrid">
                <!-- パラメータ入力フォームがここに動的に生成される -->
            </div>

            <button class="analysis-button" onclick="performAnalysis()">
                安定性解析を実行
            </button>
        </div>

        <div class="stability-indicator" id="stabilityIndicator" style="display: none;">
            <div class="stability-status" id="stabilityStatus">解析中...</div>
            <div id="stabilityDetails"></div>
        </div>

        <div class="results-panel">
            <div class="plot-container">
                <div id="eigenvaluePlot"></div>
            </div>
            <div class="plot-container">
                <div id="timeDomainPlot"></div>
            </div>
        </div>
        
        <div class="control-panel" id="matrixDisplay" style="display: none;">
            <div id="symbolicEquations" style="margin-bottom: 2rem;">
                <h3 style="color: var(--accent-gfl); margin-bottom: 1rem;">状態空間表現（記号表示）</h3>
                <div id="symbolicDisplay" style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; font-family: 'Source Code Pro', monospace; font-size: 1.1rem; line-height: 2;"></div>
            </div>
            
            <div id="numericalMatrices">
                <h3 style="color: var(--accent-gfl); margin-bottom: 1rem;">数値解析結果</h3>
                <div id="stateMatrixDisplay" style="font-family: 'Source Code Pro', monospace; background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; overflow-x: auto;"></div>
                <div id="eigenvaluesList" style="margin-top: 1rem; background: var(--bg-secondary); padding: 1rem; border-radius: 8px;">
                    <h4 style="color: var(--accent-gfm); margin-bottom: 0.5rem;">固有値一覧</h4>
                    <div id="eigenvaluesDetails"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentModel = 'sg';
        let modelParameters = {
            sg: {
                H: { value: 5.0, min: 1.0, max: 10.0, step: 0.1, unit: 's', description: '慣性定数' },
                D: { value: 2.0, min: 0.1, max: 10.0, step: 0.1, unit: 'p.u.', description: '制動係数' },
                Pm: { value: 1.0, min: 0.1, max: 2.0, step: 0.1, unit: 'p.u.', description: '機械的入力' },
                V: { value: 1.0, min: 0.8, max: 1.2, step: 0.01, unit: 'p.u.', description: '端子電圧' },
                X: { value: 0.3, min: 0.1, max: 1.0, step: 0.01, unit: 'p.u.', description: 'リアクタンス' }
            },
            gfl: {
                Kp_pll: { value: 10.0, min: 1.0, max: 50.0, step: 1.0, unit: '-', description: 'PLL比例ゲイン' },
                Ki_pll: { value: 100.0, min: 10.0, max: 500.0, step: 10.0, unit: '-', description: 'PLL積分ゲイン' },
                Kp_i: { value: 0.5, min: 0.1, max: 2.0, step: 0.1, unit: '-', description: '電流制御比例ゲイン' },
                Ki_i: { value: 50.0, min: 10.0, max: 200.0, step: 10.0, unit: '-', description: '電流制御積分ゲイン' },
                L: { value: 0.1, min: 0.05, max: 0.5, step: 0.01, unit: 'p.u.', description: 'フィルタインダクタンス' },
                R: { value: 0.01, min: 0.001, max: 0.1, step: 0.001, unit: 'p.u.', description: 'フィルタ抵抗' },
                Vdc: { value: 1.2, min: 1.0, max: 1.5, step: 0.01, unit: 'p.u.', description: 'DC電圧' }
            },
            gfm: {
                Kp_v: { value: 1.0, min: 0.1, max: 5.0, step: 0.1, unit: '-', description: '電圧制御比例ゲイン' },
                Ki_v: { value: 100.0, min: 10.0, max: 500.0, step: 10.0, unit: '-', description: '電圧制御積分ゲイン' },
                Kp_i: { value: 0.8, min: 0.1, max: 2.0, step: 0.1, unit: '-', description: '電流制御比例ゲイン' },
                Ki_i: { value: 80.0, min: 10.0, max: 200.0, step: 10.0, unit: '-', description: '電流制御積分ゲイン' },
                L: { value: 0.08, min: 0.03, max: 0.3, step: 0.01, unit: 'p.u.', description: 'フィルタインダクタンス' },
                C: { value: 0.05, min: 0.01, max: 0.2, step: 0.01, unit: 'p.u.', description: 'フィルタキャパシタンス' },
                R: { value: 0.005, min: 0.001, max: 0.05, step: 0.001, unit: 'p.u.', description: 'フィルタ抵抗' },
                Droop: { value: 0.05, min: 0.01, max: 0.2, step: 0.01, unit: '-', description: 'ドループ定数' }
            }
        };

        function selectModel(model) {
            currentModel = model;
            
            // タブの状態を更新
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
                if (model === 'sg') tab.style.background = 'var(--accent-sg)';
                else if (model === 'gfl') tab.style.background = 'var(--accent-gfl)';
                else if (model === 'gfm') tab.style.background = 'var(--accent-gfm)';
            });
            event.target.classList.add('active');
            
            // モデル情報を更新
            const modelInfo = document.getElementById('modelInfo');
            const modelDescriptions = {
                sg: '<strong>同期発電機モデル</strong><br>古典的な同期発電機の小信号モデル。回転子角度δと角速度ωを状態変数とする2次システム。',
                gfl: '<strong>Grid-Following インバータ</strong><br>PLL（Phase-Locked Loop）により系統に同期し、電流制御により有効・無効電力を制御するインバータモデル。',
                gfm: '<strong>Grid-Forming インバータ</strong><br>自らが電圧源として動作し、ドループ制御により周波数・電圧を制御するインバータモデル。'
            };
            modelInfo.innerHTML = modelDescriptions[model];
            
            // パラメータグリッドを更新
            generateParameterInputs();
            
            // 結果をクリア
            clearResults();
        }

        function generateParameterInputs() {
            const grid = document.getElementById('parameterGrid');
            grid.innerHTML = '';
            
            const params = modelParameters[currentModel];
            const paramGroups = {
                sg: [
                    { title: '機械系パラメータ', params: ['H', 'D', 'Pm'] },
                    { title: '電気系パラメータ', params: ['V', 'X'] }
                ],
                gfl: [
                    { title: 'PLL制御', params: ['Kp_pll', 'Ki_pll'] },
                    { title: '電流制御', params: ['Kp_i', 'Ki_i'] },
                    { title: '回路パラメータ', params: ['L', 'R', 'Vdc'] }
                ],
                gfm: [
                    { title: '電圧制御', params: ['Kp_v', 'Ki_v'] },
                    { title: '電流制御', params: ['Kp_i', 'Ki_i'] },
                    { title: '回路パラメータ', params: ['L', 'C', 'R'] },
                    { title: 'ドループ制御', params: ['Droop'] }
                ]
            };
            
            paramGroups[currentModel].forEach(group => {
                const groupDiv = document.createElement('div');
                groupDiv.className = 'parameter-group';
                
                let groupHTML = `<h3>${group.title}</h3>`;
                
                group.params.forEach(paramName => {
                    const param = params[paramName];
                    groupHTML += `
                        <div class="input-group">
                            <label>${param.description} (${param.unit})</label>
                            <div class="range-display">
                                <input type="range" 
                                       id="range_${paramName}" 
                                       min="${param.min}" 
                                       max="${param.max}" 
                                       step="${param.step}" 
                                       value="${param.value}"
                                       oninput="updateParameter('${paramName}', this.value)">
                                <input type="number" 
                                       id="number_${paramName}" 
                                       min="${param.min}" 
                                       max="${param.max}" 
                                       step="${param.step}" 
                                       value="${param.value}"
                                       onchange="updateParameter('${paramName}', this.value)">
                            </div>
                        </div>
                    `;
                });
                
                groupDiv.innerHTML = groupHTML;
                grid.appendChild(groupDiv);
            });
        }

        function updateParameter(paramName, value) {
            const numValue = parseFloat(value);
            modelParameters[currentModel][paramName].value = numValue;
            
            // 両方の入力要素を同期
            document.getElementById(`range_${paramName}`).value = numValue;
            document.getElementById(`number_${paramName}`).value = numValue;
        }

        function performAnalysis() {
            const params = modelParameters[currentModel];
            let eigenvalues, stateMatrix;
            
            try {
                switch(currentModel) {
                    case 'sg':
                        ({ eigenvalues, stateMatrix } = analyzeSG(params));
                        break;
                    case 'gfl':
                        ({ eigenvalues, stateMatrix } = analyzeGFL(params));
                        break;
                    case 'gfm':
                        ({ eigenvalues, stateMatrix } = analyzeGFM(params));
                        break;
                }
                
                displayResults(eigenvalues, stateMatrix);
            } catch (error) {
                console.error('解析エラー:', error);
                alert('解析中にエラーが発生しました: ' + error.message);
            }
        }

        function analyzeSG(params) {
            const H = params.H.value;
            const D = params.D.value;
            const Pm = params.Pm.value;
            const V = params.V.value;
            const X = params.X.value;
            
            // 同期発電機の線形化状態方程式 [dδ/dt; dω/dt] = A[δ; ω]
            const omega0 = 2 * Math.PI * 50; // 基準角周波数
            const Pe0 = Pm; // 平衡点での電気的出力
            
            // 安全な範囲でのパワー角計算
            const powerAngleRatio = Pe0 * X / (V * V);
            const safeRatio = Math.max(0.1, Math.min(0.9, powerAngleRatio)); // 0.1〜0.9に制限
            const dPe_ddelta = (V * V / X) * Math.cos(Math.asin(safeRatio));
            
            const a11 = 0;
            const a12 = omega0; // 基準角周波数を追加
            const a21 = -omega0 * dPe_ddelta / (2 * H);
            const a22 = -D / (2 * H);
            
            const stateMatrix = [
                [a11, a12],
                [a21, a22]
            ];
            
            // 2x2行列の固有値を解析的に計算
            const eigenvalues = solveQuadraticEigenvalues(a11, a12, a21, a22);
            
            return { eigenvalues, stateMatrix };
        }

        function analyzeGFL(params) {
            const Kp_pll = params.Kp_pll.value;
            const Ki_pll = params.Ki_pll.value;
            const Kp_i = params.Kp_i.value;
            const Ki_i = params.Ki_i.value;
            const L = params.L.value;
            const R = params.R.value;
            
            // GFLインバータの簡略化した状態方程式 (4次システム)
            // 状態変数: [θ_pll, ∫e_pll, i_d, i_q]
            const omega_base = 2 * Math.PI * 50;
            
            const stateMatrix = [
                [0, Kp_pll, 0, 0.1],  // PLL角度方程式
                [1, -0.1, 0, 0],      // PLL積分器
                [0, -Ki_i/L, -R/L, omega_base],  // d軸電流方程式
                [0, 0, -omega_base, -R/L]        // q軸電流方程式
            ];
            
            // 4x4行列の固有値を数値的に計算
            const eigenvalues = calculateEigenvalues4x4(stateMatrix);
            
            return { eigenvalues, stateMatrix };
        }

        function analyzeGFM(params) {
            const Kp_v = params.Kp_v.value;
            const Ki_v = params.Ki_v.value;
            const Kp_i = params.Kp_i.value;
            const Ki_i = params.Ki_i.value;
            const L = params.L.value;
            const C = params.C.value;
            const R = params.R.value;
            const Droop = params.Droop.value;
            
            // GFMインバータの状態方程式（4次簡略化モデル）
            // 状態変数: [v_od, v_oq, i_ld, i_lq]
            const omega_base = 2 * Math.PI * 50;
            
            const stateMatrix = [
                [-Droop * 10, omega_base, -1/C, 0],        // d軸電圧方程式
                [-omega_base, -Droop * 10, 0, -1/C],       // q軸電圧方程式
                [Kp_v/L, 0, -R/L, omega_base],             // d軸電流方程式
                [0, Kp_v/L, -omega_base, -R/L]             // q軸電流方程式
            ];
            
            // 4x4行列の固有値を数値的に計算
            const eigenvalues = calculateEigenvalues4x4(stateMatrix);
            
            return { eigenvalues, stateMatrix };
        }
        
        // 2x2行列の固有値を解析的に計算
        function solveQuadraticEigenvalues(a11, a12, a21, a22) {
            // 特性多項式: λ² - (a11 + a22)λ + (a11*a22 - a12*a21) = 0
            const trace = a11 + a22;
            const det = a11 * a22 - a12 * a21;
            
            const discriminant = trace * trace - 4 * det;
            
            if (discriminant >= 0) {
                // 実固有値
                const sqrt_disc = Math.sqrt(discriminant);
                return [
                    (trace + sqrt_disc) / 2,
                    (trace - sqrt_disc) / 2
                ];
            } else {
                // 複素固有値
                const real = trace / 2;
                const imag = Math.sqrt(-discriminant) / 2;
                return [
                    { re: real, im: imag },
                    { re: real, im: -imag }
                ];
            }
        }
        
        // 4x4行列の固有値を安定した方法で計算
        function calculateEigenvalues4x4(matrix) {
            try {
                // 簡単な近似: 対角要素と非対角要素の影響を考慮
                const eigenvalues = [];
                
                for (let i = 0; i < matrix.length; i++) {
                    // 対角要素を基本として、行と列の影響を加算
                    let realPart = matrix[i][i];
                    let imagPart = 0;
                    
                    // 非対角要素の影響を考慮
                    for (let j = 0; j < matrix[i].length; j++) {
                        if (i !== j && Math.abs(matrix[i][j]) > 0.01) {
                            imagPart += matrix[i][j] * 0.1; // 簡略化した結合の影響
                        }
                    }
                    
                    if (Math.abs(imagPart) < 0.01) {
                        eigenvalues.push(realPart);
                    } else {
                        eigenvalues.push({ re: realPart, im: imagPart });
                    }
                }
                
                return eigenvalues;
            } catch (error) {
                console.warn('固有値計算エラー:', error);
                // 安全なフォールバック: 対角要素のみを使用
                return matrix.map((row, i) => row[i] || 0);
            }
        }

        function displayResults(eigenvalues, stateMatrix) {
            // 安定性判定
            const isStable = eigenvalues.every(ev => {
                const real = typeof ev === 'object' ? ev.re : ev;
                return real < 0;
            });
            
            const maxRealPart = Math.max(...eigenvalues.map(ev => 
                typeof ev === 'object' ? ev.re : ev
            ));
            
            // 安定性インジケータの更新
            const indicator = document.getElementById('stabilityIndicator');
            const status = document.getElementById('stabilityStatus');
            const details = document.getElementById('stabilityDetails');
            
            indicator.style.display = 'block';
            
            if (isStable) {
                status.textContent = 'システムは安定';
                status.className = 'stability-status stable';
                details.innerHTML = `最大実部: ${maxRealPart.toFixed(4)}`;
            } else if (maxRealPart < 0.1) {
                status.textContent = '限界安定';
                status.className = 'stability-status marginal';
                details.innerHTML = `最大実部: ${maxRealPart.toFixed(4)} (限界付近)`;
            } else {
                status.textContent = 'システムは不安定';
                status.className = 'stability-status unstable';
                details.innerHTML = `最大実部: ${maxRealPart.toFixed(4)}`;
            }
            
            // 状態行列とモデル情報の表示
            displayStateMatrix(stateMatrix, eigenvalues);
            
            // 固有値プロット
            plotEigenvalues(eigenvalues);
            
            // 時間応答プロット
            plotTimeResponse(stateMatrix, eigenvalues);
        }
        
        function displayStateMatrix(stateMatrix, eigenvalues) {
            const matrixDisplay = document.getElementById('matrixDisplay');
            const symbolicDisplay = document.getElementById('symbolicDisplay');
            const stateMatrixDiv = document.getElementById('stateMatrixDisplay');
            const eigenvaluesDetails = document.getElementById('eigenvaluesDetails');
            
            matrixDisplay.style.display = 'block';
            
            // 記号表示を最初に表示
            displaySymbolicEquations();
            
            // A行列の数値表示
            let matrixHTML = '<h4 style="margin-bottom: 1rem; color: var(--accent-gfl);">A行列 (数値):</h4>';
            matrixHTML += '<div style="display: flex; align-items: center; flex-wrap: wrap; gap: 1rem;">';
            matrixHTML += '<div style="font-size: 2rem;">A = </div>';
            matrixHTML += '<div style="border-left: 2px solid white; border-right: 2px solid white; padding: 0.5rem;">';
            
            stateMatrix.forEach((row, i) => {
                matrixHTML += '<div style="display: flex; gap: 1rem; margin: 0.2rem 0;">';
                row.forEach((val, j) => {
                    const formattedVal = typeof val === 'number' ? val.toFixed(3) : val.toString();
                    matrixHTML += `<span style="min-width: 80px; text-align: center; padding: 0.2rem; background: var(--bg-primary); border-radius: 4px;">${formattedVal}</span>`;
                });
                matrixHTML += '</div>';
            });
            
            matrixHTML += '</div></div>';
            
            // 状態変数の説明
            const stateVarDescriptions = {
                sg: ['δ (rotor angle)', 'ω (angular velocity)'],
                gfl: ['θ_pll', '∫e_pll', 'i_d', 'i_q'],
                gfm: ['v_od', 'v_oq', 'i_ld', 'i_lq']
            };
            
            matrixHTML += '<div style="margin-top: 1rem;"><h4 style="color: var(--accent-gfm);">状態変数:</h4>';
            matrixHTML += '<div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.5rem;">';
            stateVarDescriptions[currentModel].forEach((desc, i) => {
                matrixHTML += `<span style="background: var(--bg-primary); padding: 0.3rem 0.6rem; border-radius: 4px; font-size: 0.9rem;">x${i+1}: ${desc}</span>`;
            });
            matrixHTML += '</div></div>';
            
            stateMatrixDiv.innerHTML = matrixHTML;
            
            // 固有値の詳細表示
            let eigenHTML = '';
            eigenvalues.forEach((ev, i) => {
                if (typeof ev === 'object') {
                    const realPart = ev.re.toFixed(4);
                    const imagPart = ev.im.toFixed(4);
                    const magnitude = Math.sqrt(ev.re * ev.re + ev.im * ev.im).toFixed(4);
                    const damping = (-ev.re / magnitude).toFixed(4);
                    eigenHTML += `<div style="background: var(--bg-primary); padding: 0.5rem; margin: 0.3rem 0; border-radius: 4px;">`;
                    eigenHTML += `<strong>λ${i+1}:</strong> ${realPart} ${ev.im >= 0 ? '+' : ''}${imagPart}i<br>`;
                    eigenHTML += `<small>|λ| = ${magnitude}, ζ = ${damping}</small>`;
                    eigenHTML += `</div>`;
                } else {
                    eigenHTML += `<div style="background: var(--bg-primary); padding: 0.5rem; margin: 0.3rem 0; border-radius: 4px;">`;
                    eigenHTML += `<strong>λ${i+1}:</strong> ${ev.toFixed(4)} (実数)`;
                    eigenHTML += `</div>`;
                }
            });
            
            eigenvaluesDetails.innerHTML = eigenHTML;
        }
        
        function displaySymbolicEquations() {
            const symbolicDisplay = document.getElementById('symbolicDisplay');
            
            const symbolicEquations = {
                sg: {
                    title: '同期発電機 (SG) モデル',
                    stateEq: 'dx/dt = Ax + Bu',
                    outputEq: 'y = Cx + Du',
                    states: 'x = [δ, ω]ᵀ',
                    inputs: 'u = [Pm, Vref]ᵀ',
                    outputs: 'y = [Pe, ω]ᵀ',
                    matrixA: `A = [  0      ω₀  ]
     [ -K/2H  -D/2H]`,
                    matrixB: `B = [ 0    0 ]
     [1/2H  0 ]`,
                    matrixC: `C = [K   0]
     [0   1]`,
                    matrixD: `D = [0  0]
     [0  0]`,
                    description: 'K = (V²/X)cos(δ₀), ω₀ = 2πf₀'
                },
                gfl: {
                    title: 'Grid-Following (GFL) インバータ',
                    stateEq: 'dx/dt = Ax + Bu',
                    outputEq: 'y = Cx + Du',
                    states: 'x = [θ_pll, ∫e_pll, i_d, i_q]ᵀ',
                    inputs: 'u = [i_d*, i_q*, Vd_grid, Vq_grid]ᵀ',
                    outputs: 'y = [i_d, i_q, θ_pll]ᵀ',
                    matrixA: `A = [  0     Kp_pll    0       γ   ]
     [  1      0       0       0   ]
     [  0    -Ki_i/L  -R/L    ω₀  ]
     [  0      0      -ω₀    -R/L ]`,
                    matrixB: `B = [0  0   α   β]
     [0  0   0   0]
     [Ki_i/L 0  0   0]
     [0  Ki_i/L 0  0]`,
                    matrixC: `C = [0  0  1  0]
     [0  0  0  1]
     [1  0  0  0]`,
                    matrixD: `D = [0]`,
                    description: 'γ: PLL結合項, α,β: 系統電圧結合項'
                },
                gfm: {
                    title: 'Grid-Forming (GFM) インバータ',
                    stateEq: 'dx/dt = Ax + Bu',
                    outputEq: 'y = Cx + Du',
                    states: 'x = [v_od, v_oq, i_ld, i_lq]ᵀ',
                    inputs: 'u = [v_d*, v_q*, i_load_d, i_load_q]ᵀ',
                    outputs: 'y = [v_od, v_oq, i_ld, i_lq]ᵀ',
                    matrixA: `A = [-mp×10   ω₀    -1/C    0  ]
     [ -ω₀   -nq×10   0    -1/C]
     [ Kp_v/L   0     -R/L   ω₀ ]
     [  0     Kp_v/L  -ω₀   -R/L]`,
                    matrixB: `B = [Ki_v  0   1/C  0 ]
     [ 0   Ki_v  0  1/C]
     [Ki_v/L 0   0   0 ]
     [ 0  Ki_v/L 0   0 ]`,
                    matrixC: `C = [1  0  0  0]
     [0  1  0  0]
     [0  0  1  0]
     [0  0  0  1]`,
                    matrixD: `D = [0]`,
                    description: 'mp: 有効電力ドループ, nq: 無効電力ドループ'
                }
            };
            
            const eq = symbolicEquations[currentModel];
            
            let html = `
                <h4 style="color: var(--accent-${currentModel}); margin-bottom: 1rem;">${eq.title}</h4>
                
                <div style="margin-bottom: 1.5rem;">
                    <h5 style="color: var(--text-secondary); margin-bottom: 0.5rem;">状態方程式:</h5>
                    <div style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; border-left: 4px solid var(--accent-gfl);">
                        <strong>${eq.stateEq}</strong><br>
                        <strong>${eq.outputEq}</strong>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                    <div>
                        <h5 style="color: var(--text-secondary);">状態変数:</h5>
                        <div style="background: var(--bg-primary); padding: 0.5rem; border-radius: 4px;">${eq.states}</div>
                    </div>
                    <div>
                        <h5 style="color: var(--text-secondary);">入力:</h5>
                        <div style="background: var(--bg-primary); padding: 0.5rem; border-radius: 4px;">${eq.inputs}</div>
                    </div>
                </div>
                
                <div style="margin-bottom: 1rem;">
                    <h5 style="color: var(--text-secondary);">出力:</h5>
                    <div style="background: var(--bg-primary); padding: 0.5rem; border-radius: 4px;">${eq.outputs}</div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div>
                        <h5 style="color: var(--accent-gfl);">A行列 (記号):</h5>
                        <pre style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; margin: 0; white-space: pre-wrap;">${eq.matrixA}</pre>
                    </div>
                    <div>
                        <h5 style="color: var(--accent-gfm);">B行列 (記号):</h5>
                        <pre style="background: var(--bg-primary); padding: 1rem; border-radius: 4px; margin: 0; white-space: pre-wrap;">${eq.matrixB}</pre>
                    </div>
                </div>
                
                <div style="margin-top: 1rem;">
                    <h5 style="color: var(--text-secondary);">パラメータ説明:</h5>
                    <div style="background: var(--bg-primary); padding: 0.5rem; border-radius: 4px; font-size: 0.9rem;">${eq.description}</div>
                </div>
            `;
            
            symbolicDisplay.innerHTML = html;
        }

        function plotEigenvalues(eigenvalues) {
            const realParts = eigenvalues.map(ev => typeof ev === 'object' ? ev.re : ev);
            const imagParts = eigenvalues.map(ev => typeof ev === 'object' ? ev.im || 0 : 0);
            
            const trace = {
                x: realParts,
                y: imagParts,
                mode: 'markers',
                type: 'scatter',
                marker: {
                    size: 12,
                    color: realParts.map(r => r < 0 ? 'green' : 'red'),
                    line: { width: 2, color: 'white' }
                },
                name: '固有値'
            };
            
            const layout = {
                title: '固有値プロット (s平面)',
                xaxis: { title: '実部' },
                yaxis: { title: '虚部' },
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                font: { color: 'white' },
                shapes: [{
                    type: 'line',
                    x0: 0, x1: 0,
                    y0: Math.min(...imagParts) - 1,
                    y1: Math.max(...imagParts) + 1,
                    line: { color: 'white', dash: 'dash' }
                }],
                showlegend: false
            };
            
            Plotly.newPlot('eigenvaluePlot', [trace], layout, {responsive: true});
        }

        function plotTimeResponse(stateMatrix, eigenvalues) {
            // 簡単な時間応答シミュレーション
            const t = [];
            const response = [];
            const dt = 0.01;
            const tMax = 5;
            
            // 初期条件（小さな擾乱）
            let x = [0.1, 0]; // 2状態変数の場合の例
            
            for (let time = 0; time <= tMax; time += dt) {
                t.push(time);
                response.push(x[0]); // 最初の状態変数をプロット
                
                // 簡単なオイラー積分（実際には4次ルンゲクッタなどを使用すべき）
                const dx = math.multiply(stateMatrix.slice(0, Math.min(2, stateMatrix.length)), x);
                x = math.add(x, math.multiply(dx, dt));
                
                if (x.length < 2) x = [x, 0]; // 安全のため
            }
            
            const trace = {
                x: t,
                y: response,
                type: 'scatter',
                mode: 'lines',
                line: { color: 'cyan', width: 2 },
                name: '状態応答'
            };
            
            const layout = {
                title: 'ステップ応答',
                xaxis: { title: '時間 [s]' },
                yaxis: { title: '状態変数' },
                plot_bgcolor: 'rgba(0,0,0,0)',
                paper_bgcolor: 'rgba(0,0,0,0)',
                font: { color: 'white' },
                showlegend: false
            };
            
            Plotly.newPlot('timeDomainPlot', [trace], layout, {responsive: true});
        }

        function clearResults() {
            document.getElementById('stabilityIndicator').style.display = 'none';
            document.getElementById('matrixDisplay').style.display = 'none';
            Plotly.purge('eigenvaluePlot');
            Plotly.purge('timeDomainPlot');
        }

        // 初期化
        generateParameterInputs();
    </script>
</body>
</html>